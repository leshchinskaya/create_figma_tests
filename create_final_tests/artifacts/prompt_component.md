На основании артефактов и информации ниже, сгенерируй компонентные тесты на фичу "Главная" и подфичу "Витрина"
Перед этим детально и подробно проанализируй информацию и вводные данные и только потом генерируй ответ в соответствии с
правилами.
Кроме логики фичи обязательно обдумай содержание тестов прежде чем генерировать их.
За хорошие, детальные и продуманные тесты ты получишь награду $200.

### Бизнес-требования по фиче

Описание логики с точными названиями фич, секций и экранов из Figma.
Воспринимай логику из раздела "Общее" как то, что стоит учитывать при генерации (например общая обработка ошибок), но не
как фичу которую нужно покрыть тестами.

Содержимое файла `req.md`:

```markdown
{{REQ_CONTENT}}
```

### Swagger-спецификация

Описание API, моделей и параметров запросов.
Ссылка на Swagger: {{SWAGGER_URL}}
Содержимое файла `swagger.yaml`:

```yaml
{{SWAGGER_CONTENT}}
```

### Тесты на дизайн

Краткие сценарии с Summary, содержащие названия секций/экранов из Figma.
Используй их содержимое для тестов компоновки экранов.
Не используй названия из Figma для генерации названий тестов, используй их только внутри тестов. Названия самих тестов
должны содержать user friendly названия
Содержимое файла `tests_from_figma.csv`:

```csv
{{TESTS_FROM_FIGMA_CONTENT}}
```

### Правила генерации тестов

#### Спецификация формата тестов

Формат вывода - единый JSON-файл с массивом объектов.
Каждый объект обязан соответствовать схеме TestCase (см. ниже) и описывать одну Jira сущность Test.
Не оборачивай результат в Markdown, выводи чистый JSON.

```yaml
{{JSON_SCHEME_CONTENT}}
```

Правила:

* summary - ≤100 символов, декларативно. В конце не ставь точку. Строго соблюдай формат названия из структуры проверок.
* description - должен содержать название файла ТЗ и ссылку на дизайн (из тестов figma). Каждый пункт на отдельной
  строке
* labels - Лейблы пишутся слитно без пробелов. Пока что передавай пустой список.
* steps - action не может быть пустой строкой, data и result могут быть (result может быть пустым только для глобальных
  предусловий или тестов на компоновку)
* estimate - integer, минуты
* testCaseType - всегда component
* testRepositoryPath - обязательно в нижнем регистре. Корневая папка - название фичи из документации. Если фича состоит
  из нескольких экранов - делай для каждого экрана подпапку с названием экрана, но не делай вложенные экраны, только 1
  уровень глубины.
    * Пример правильной структуры для фичи "Каталог" с экранами "Список товаров" и "Фильтры": каталог/список товаров/,
      каталог/фильтры/.
    * Пример неправильной структуры: каталог/компоновка/, каталог/запросы/. Запрещено создавать папки, основанные на
      типе теста (компоновка, запросы, ptr, пагинация) или названии элемента. Структура папок должна отражать только
      иерархию экранов фичи.

Важные нюансы:

* Внимательно следи за синтаксисом, результатом должен быть валидный массив json объектов в соответствии со схемой.
* Если внутри json нужны кавычки (например название кнопки), используй одиночные кавычки (').
* *Никогда* не используй `` (backticks) для monospace форматирования. Вместо этого используй {{text}} конструкцию.
* Для блоков кода (если нужны) *всегда* используй "{code}text{code}" конструкцию, но будь внимателен с фигурными
  скобками.
* Для форматирования запросов приоритизируй {{text}} формат в виде списка вместо блока кода.
* В тз могут встречаться конструкции с {}, например описание запроса "GET /collection/{collectionId}".
  В этом случае используй <> для замены фигурных скобок чтобы правильно форматировалось в Jira.
  Например "{{GET /collection/<collectionId>}}"
* Запрет на использование ` (backticks) и обязательная самопроверка:
    * Правило: Использование символа обратной кавычки (backtick) `` для любого вида форматирования, включая выделение
      переменных, фрагментов кода или текста monospace шрифтом, строго запрещено. Вместо этого всегда используй
      конструкцию {{текст}}.
    * Пример:
        * Неправильно: Отображается текст на основе `expiring` и `expiresAt`.
        * Правильно: Отображается текст на основе {{expiring}} и {{expiresAt}}.
    * Процедура самопроверки: Перед тем как завершить генерацию ответа, ты обязан выполнить финальную проверку всего
      сгенерированного JSON на предмет наличия символа обратной кавычки (`). Если хотя бы один такой символ найден, ты
      должен немедленно исправить его на корректный формат {{}} перед выдачей финального ответа.
    * Исключение: единственным исключением может быть использование этого символа не для форматирования, а для
      содержания проверки, например в поле нельзя ввести этот символ и надо явно указать этот запрет.

#### Структура проверок и их содержимое

##### Структура проверок

У нас есть четкая структура проверок от которой нельзя отклоняться за *редкими* исключениями. Ниже предоставлено
описание проверок и подробности их написания. В случае отклонения обязательно укажи это в ответе после генерации тестов.

Общие правила:

* Все проверки имеют следующий формат наименования: "Фича. Экран/шторка (итд). Элемент - тест, уточнение".
  Далее для удобства F = фича, S = экран, E = элемент.
  Если нет элемента, то наименование упрощается до "F. S - тест, уточнение".
  Если фича == экран, то "F - тест, уточнение".
  Если экраны вложенные - указывай цепочку, например "F. S1. S2 - тест".
  Уточнение не обязательное, но если оно есть - после запятой после теста.
  Более подробно примеры будут разобраны в каждом конкретном виде теста.
  Никогда не ставь точку в конце названия или перед дефисом.
  Строго следуй формату наименования за исключением тестов которые явно не попадают под классификацию. В таком случае
  *обязательно* укажи это в ответе после генерации тестов.
* Все проверки обязательно содержат ссылку на ТЗ и дизайн. Если тест на логику, а не на компоновку, то ссылка должна
  быть на общий файл/компоновку.
* Для тестов, описывающих UI-компоновку или логику, если данные UI-элементов получены через API, обязательно укажи в
  description ссылку на сваггер, источник данных (HTTP-метод и эндпоинт) и ссылку-якорь на соответствующую
  модель в Swagger (#/components/schemas/...).
* Разделяй описание новыми строками для удобства.
* Все описанные ниже тесты следуют принципу best effort - они одновременно обязательные, но только при условии, что в
  проверке есть смысл и она не избыточная.
* В описании шагов тестов придерживайся императивной инфинитивной формы (сделать, тапнуть итд) для действий QA, и
  декларативной для среды (в прошедшем времени для action, в настоящем времени для result, что-то случилось -> что-то
  отображается).
  При этом не описывай *как* добиться этого эффекта (например, никогда не пиши "подменить ответ на запрос")
* Называй (Error/Empty/No Connection) State на английском несмотря на правило использовать русский язык.
* Разделение логики теста по полям action/data/result:
    * action - содержит действие необходимое для достижения проверяемого результата.
    * data - входные данные и предусловия, в некоторых случаях данные для результата (например список параметров и их
      значений, которые ожидаются).
    * result - проверяемый результат после выполнения теста action с учетом данных data.
* Расположение предусловия:
    * По умолчанию предусловия располагаются в data.
    * Если же data нужно для данных result, то предусловие нужно располагать в action над шагами.
* Внутри *result* если нужны *одновременные* проверяемые результаты (логическое AND) - используй bullet-list для
  *каждого* результата. Например:
  ```
  - Отображается кнопка X.
  - Кнопка Y отсутствует.
  ```
* Внутри *action* если нужны *последовательные* действия - используй нумерованный список для *каждого* действия/условия.
  Например:
  ```
  1. Перейти на экран X.
  2. В ответе на запрос Y пришел параметр P.
  ```
* При использовании списков в полях action или result, следуй синтаксису Jira для вложенности:
    * Для маркированных списков используй - для первого уровня, -- для второго, --- для третьего и так далее.
    * Для нумерованных списков используй # для первого уровня, ## для второго, и так далее.

1. Компоновки
    1. Компоновка экрана
        * Формат названия: "F. S - компоновка" / "F - компоновка"
        * Под экраном я понимаю любой вид элемента который имеет навигацию:
            * Экран
            * Шторка (bottomsheet)
            * Модальный экран (iOS вариант экрана)
            * TUP (thank you page)
        * Допустимы пустые result поля для простых элементов, вроде скелетонов
        * Шаги - каждый шаг проверяет один элемент, где action = элемент. Порядок сверху вниз по экрану. Пиши в
          формате "Проверить элемент" для читаемости.
            * Статусбар - упомянуть, на iOS по тапу скроллит в начало экрана списки
            * AppBar / NavBar - проверить заголовок и описать какие содержатся элементы. Если с элементами можно
              взаимодействовать - описать их в следующих шагах
            * Возврат назад - после описания кнопки назад или крестика нужно добавить как обрабатывается:
                * backswipe на iOS - возврат на прошлый экран - даже если он не поддерживается, укажи это явно
                * системная кнопка назад на Android - возврат на прошлый экран
            * Картинки - просто упомянуть
            * Текст - корректный текст указать в result, в action указать краткое название текста. Если текст имеет
              ограничение по строкам - указать в result.
            * Кнопки - в action указать текст кнопки если есть, иначе описать. В result нужно проверить pressed state
              (достаточно упомянуть) и кратко описывает результат при тапе
            * Обычные поля - в result нужно указать placeholder
            * Поля поиска - аналогично, нужно указать hint
            * Глобальные навигационные элементы (Tab Bar, Header итд)
                * Принцип: Глобальные элементы, которые видны на нескольких экранах (например, нижняя панель
                  навигации/Tab Bar), являются неотъемлемой частью компоновки этих экранов и должны проверяться всегда.
                * Источник информации: Часто такие элементы явно указываются в артефактах, не связанных с основным
                  текстом ТЗ, например, в тестах из Figma. Ты обязан анализировать все источники на предмет таких
                  компонентов.
                * Реализация: В каждом тесте на компоновку экрана, где предполагается наличие такого элемента,
                  должен быть добавлен шаг для его проверки. Содержимое шага:
                    * Убедиться, что Tab Bar отображается в нижней части экрана.
                    * Перечислить все табы, которые он содержит (обычно иконка + название).
                    * Явно указать, какой таб является активным на текущем проверяемом экране.
                    * Кратко описать результат тапа на другие (неактивные) табы (например, "Тап на таб 'A'
                      открывает экран 'B'").
                    * Описать возврат на таб после перехода на другой таб - состояние экрана должно сохраниться.
                    * Описать тап на текущий таб - если находимся не на первом уровне, должен быть возврат на корневой
                      экран таба.
            * Остальные элементы делаются по аналогии
            * Если значения приходят в ответе на запрос - укажи в Data параметр ответа который влияет на значение
    2. Компоновка шторки
        * Все аналогично компоновке экрана, но в возврате назад проверяй:
            * Смахивание и тап на пустую область - зависит от требований
            * Backswipe iOS не работает - укажи это явно
            * Тап на системную кнопку Android - работает
    3. Компоновка TUP (Thank You Page)
        * Все аналогично компоновке экрана со следующими уточнениями:
            * При возврате назад явно проверяй какой экран открывается, обычно это точка входа флоу, а не прошлый
              экран.
            * Бывают TUP с ошибкой, в таком случае создай еще один отдельный тест для проверки этого состояния.
    4. Компоновка Empty State/Error State/No Connection State
        * Все аналогично компоновке экрана, но создаем обязательно отдельные проверки под *каждый* state если они есть
        * Проверка кнопки 'Повторить' (или аналогичной) не ограничивается ее наличием в тесте на компоновку. Эта кнопка
          является самостоятельной точкой вызова запросов. В дополнение к тесту на компоновку заглушки, ты обязан
          создать для этого действия полный набор тестов на запросы согласно правилам из раздела 3: 'Отправка запроса'
          (для успешного повтора) и 'Отправка запроса с ошибкой' (для повторной ошибки).
2. Логика работы в стеке экранов
    * Формат названия: "F. S - логика работы в стеке экранов" / "F - логика работы в стеке экранов"
    * Проверка нужна когда при закрытии экрана происходит не обычный возврат на прошлый экран, например есть обработка
      алёртом "вы точно хотите закрыть?", переход на какой-то экран и другие необычные события, например сохранение
      данных итд.
    * Если используется данная проверка, то в компоновке не нужно проверять логику закрытия экрана. Убедись что на две
      эти проверки (компоновка и логика работы в стеке) закрытие экрана покрыто.
    * Шаги - каждый шаг описывает действие юзера и ожидаемое поведение. Возможные проверки:
        * Тап на кнопку - в result пишем ожидаемое поведение, например появление алёрта. Так же кратко описываем
          компоновку в этом шаге, включая текстовки алёрта
        * Отказ от алёрта (тап на кнопку нет)
        * Согласие с алёртом (тап на кнопку выйти)
        * Сохранение данных формы
        * Особая логика при сворачивании/разворачивании приложения
        * Очистка кеша/авторизации
3. Отправка запроса
    1. Отправка запроса
        * Формат названия: "F. S - запрос x" / "F - запрос x"
        * Запрос в *названии* должен отражать цель запроса, а не конкретный метод (например запрос авторизации,
          запрос смс кода).
        * В *шагах* каждый запрос *обязательно* должен в виде метод + путь, например `{{GET /api/endpoint}}`.
          Несколько запросов формируй в виде буллит списка.
          Недопустимо описывать отправку запросов в общей форме.
          Правило касается ВСЕХ тестов на запросы в любом виде и форме.
        * Проверка нужна всегда при отправке запроса. Это можно происходить при открытии экрана, при нажатии на
          кнопку или по любой другой причине.
          Для одинакового запроса который вызывается разными элементами UI нужны отдельные тесты.
        * Если по триггеру отправляются несколько запросов (параллельно или последовательно) - это нужно обработать
          в одной проверке.
        * Важно глобально различать разницу между "кнопка открывает экран, а экран отправляет запрос" и "кнопка
          вызывает запрос". В первом случае в кнопке мы проверяем открытие экрана и не более, а запрос проверяем в
          тестах экрана.
        * Все успешные кейсы обрабатываются в одной сущности теста и разделяются шагами, недопустимо создавать
          несколько сущностей для одного запроса.
        * Шаги:
            * Каждый шаг это мини-сценарий который идет от триггера до конца запросов
            * Между action и result возникает маппинг - если есть список 1-2-3 в action, то result 1-2-3
              соответствуют результату *после* этого шага. Т.е. action 1 - result 1, action 2 - result 2
            * При указании запроса обязательно указывай метод и path. Используй monospace форматирование.
            * Прикрепляй и описывай логику с параметрами если она важна для логики проверки, ссылайся на swagger.
            * Empty state считается позитивной проверкой, поэтому должен покрываться в этом тесте (при условии, что он
              есть). В GET запросах со списками очень часто должна быть обработка Empty State (каталог, поиск итд).
            * При проверке лоадера упоминай что он должен длиться всю длительность запроса
            * Каждый шаг состоит из
                * Предусловие (только если нужно)
                * Триггер запроса (например тап на кнопку) - результат (какой запрос отправился, какой лоадер
                  отображается)
                * Успех запроса (как выглядит, например 200 и модель swagger) - результат (UI отображает X, Y, Z,
                  возможно отправляется следующий запрос)
                * 2 и 3 для каждого последовательного запроса. Параллельные запросы объединяются в один мини-шаг
    2. Отправка запроса с ошибкой
        * Формат названия: "F. S - запрос x, ошибка" / "F - запрос x, ошибка"
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * Вместо успеха мы проверяем обработку ошибок
            * Обязательно указывай какой запрос отправляется, несмотря на то что в успешном тесте мы это проверили
            * Без интернета и таймаут проверяется в этом тесте вместе с HTTP ошибками.
            * Длительность таймаута должна быть явно прописана.
            * В каждом тесте на ошибку запросов должны проверяться *все* общие ошибки проекта (400, 500, таймаут, без
              интернета обязательно, так же в общем ТЗ могут быть дополнительные общие ошибки) и специфичные указанные
              для конкретного запроса.
            * В запросах использующих авторизацию (токен, куки итд) должна проверяться логика рефреш токена.
              Обычное поведение такое:
                * При получении 401 приложение отправляет запрос на обновление токена, после чего повторяет изначальный
                  запрос (или всю цепочку если запросов несколько).
                * При получении 403 на запрос обновление токена приложение делает принудительный логаут пользователя.
                * В случае если логика не прописана в ТЗ явно, описывай этот тест с пометкой (?) и TODO.
                * Если логика описана в ТЗ явно, используй ее, но обязательно проверяй как обновление токена, так и
                  принудительный логаут для каждого запроса с авторизацией.
                * Для запросов БЕЗ авторизации пиши проверку, в которой проверяется что при получении 401 приложение НЕ
                  отправляет запрос на обновление токена - это типичный дефект при внедрении механизма обновления
                  токена.
            * Тестирование параллельных запросов:
                * Принцип: Если несколько запросов выполняются параллельно и ошибка любого из них приводит к одинаковой
                  общей обработке (например, Error State), следует применять оптимизированную стратегию тестирования,
                  чтобы избежать комбинаторного взрыва проверок.
                * Реализация (Стратегия "Один тип ошибки на все запросы + Все типы ошибок на один запрос"):
                    * Проверка каждого источника отказа: Возьми один репрезентативный тип ошибки (например, 500 Internal
                      Server Error). Создай по одному шагу для каждого параллельного запроса, где только этот конкретный
                      запрос завершается с данной ошибкой, а остальные — успешно. Это подтвердит, что механизм обработки
                      отказа срабатывает для ошибки любого запроса.
                    * Проверка всех типов ошибок: Возьми один репрезентативный запрос (например, первый или самый
                      важный). Создай по одному шагу для каждого оставшегося типа системных ошибок (4xx, таймаут, нет
                      сети и т.д.), где только этот запрос завершается с соответствующей ошибкой. Это подтвердит, что
                      все типы ошибок корректно обрабатываются.
                    * Стратегия делает предположение, что если все запросы обрабатывают базовую ошибку, и все ошибки
                      обрабатываются важным запросом, то все запросы обрабатывают все базовые/общие ошибки.
                * Поведение "Fail-Fast": В каждом шаге нужно явно проверять, что приложение реагирует на ошибку
                  немедленно, не дожидаясь завершения остальных параллельных запросов.
                * Данная стратегия применяется только для *общих* ошибок (в пункте выше).
                  Уникальные ошибки для конкретных запросов, а так же ошибки связанные с состоянием авторизации
                  (401 и 403) должны обрабатываться для каждого запроса, т.к. шанс или последствия дефектов для них
                  выше.
                * Исключение: Если в ТЗ явно указано, что ошибки разных запросов обрабатываются по-разному, данная
                  стратегия оптимизации применяется только для запросов которые вызывают падение, а для каждого
                  уникального поведения создаётся отдельная проверка в формате "Все обязательные запросы завершились
                  успешно, все необязательные запросы вернули ошибку -> В UI ошибки нет (или другая логика из ТЗ)".
            * Для каждой ошибки создавай отдельный шаг-проверка, даже если обработка нескольких ошибок одинаковая. Это
              нужно для явной проверки всех ошибок.
            * Большое внимание уделяй наличию и обработке 401/403 ошибок. Часто 401 вызывает refresh-token логику для
              запросов с авторизацией, а 403 сигнализирует что токен истек. Однако это должно быть явно описано хотя бы
              в общем ТЗ.
            * Как описывать проверку без интернета.
                * Одна проверка формата "выключить интернет - сделать запрос". В таком случае обработка == обработке без
                  интернета (например no connection state, снэк с текстом про интернет итд).
                  Для нескольких запросов проверять нужно старт последовательности т.к. проверка идет до запроса.
                * Для каждого запроса проверка прерывания интернета формата "сделать запрос - выключить интернет до
                  получения ответа".
                  Ожидаемое поведение по умолчанию: отображается ошибка аналогичная общей ошибке (400, 500 итд) т.к. с
                  точки зрения МП запрос уже был отправлен. Если в ТЗ указано иначе - используем обработку из ТЗ.
            * В отличие от HTTP ошибок, без интернета не может случиться между запросами или для одного запроса из
              двух - по крайней мере это нереально проверить - поэтому используй логику "выключить интернет - триггер -
              результат".
            * Не должно быть одновременно error/no connection state и снэков. Снэк подразумевает что содержимое экрана
              остается, а заглушка - нет.
4. Пагинация
    1. Пагинация
        * Формат названия: "F. S - пагинация" / "F - пагинация"
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * В ожидаемых результатах нужно проверить что содержимое не дублируется и отображается в правильном порядке.
            * В action обязательно указывай *как* сделать пагинацию для данного элемента. Почти всегда это скролл вниз
              до границы экрана.
    2. Пагинация с ошибкой
        * Формат названия: "F. S - пагинация, ошибка" / "F - пагинация, ошибка"
        * Логика совпадает с отправкой запроса с ошибкой со следующими уточнениями:
            * При ошибке может быть снэк или маленький error state в конце списка.
            * При снэке сразу проверяем что можно повторить пагинацию, заглушку проверяем далее отдельными тестами.
    3. Повтор пагинации
        * Формат названия: "F. S - повтор пагинации" / "F - повтор пагинации"
        * Проверка нужна только если после ошибки пагинации остается заглушка
        * Логика совпадает с успешной пагинацией со следующими уточнениями:
            * Первым шагом проверяем компоновку заглушки в соответствии с правилами тестов на компоновку error state
            * Дальнейшие шаги - аналогично проверке пагинации с успехом
    4. Повтор пагинации с ошибкой
        * Формат названия: "F. S - повтор пагинации, ошибка" / "F - повтор пагинации, ошибка"
        * Проверка нужна только если после ошибки пагинации остается заглушка
        * Логика совпадает с пагинацией с ошибкой со следующими уточнениями:
            * Первым шагом проверяем компоновку заглушки в соответствии с правилами тестов на компоновку error state
            * Дальнейшие шаги - аналогично проверке пагинации с ошибкой
5. Pull to refresh
    1. PTR
        * Формат названия: "F. S - PTR" / "F - PTR"
        * Проверка нужна только если на экране есть PTR
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * Важно вместо лоадера проверить индикатор загрузки - он должен длиться столько сколько длятся запросы
            * Нужно внимательно проверить какие запросы должны повторяться при PTR
    2. PTR с ошибкой
        * Формат названия: "F. S - PTR, ошибка" / "F - PTR, ошибка"
        * Проверка нужна только если на экране есть PTR
        * Логика совпадает с отправкой запроса с ошибкой со следующими уточнениями:
            * Внимательно учитывай обработку ошибки. В основном это снэк, но может быть и Error State, тогда нужно
              указать правильные стейты (empty/error/no connection). Аналогично запросам, не может быть одновременно
              снэк и заглушка.
            * По умолчанию если ошибка не описана - предполагай что будет появляться снэкбар, а содержимое экрана
              останется.
            * Там где поддерживается - не забывай проверять empty ответ
6. Кеширование запросов
    1. Успешный запрос
        * Проверки на кеш дублируют проверки запросов. Дублируются все типы тестов - запрос, PTR, пагинация, повторы.
          При наличии логики с кешем, основной тест помечается уточнением "без кеша", и дополнительно пишется
          тест на проверку кеша.
        * Формат названия: "F. S - T, кеш" / "F - T, кеш". Например "Каталог - запрос списка товаров, кеш".
          Оригинальные тесты помечаются "без кеша", например "Каталог - запрос списка товаров, без кеша".
        * Кеширование запросов должно быть *явно* прописано в техническом задании для конкретного запроса или экрана, в
          противном случае считай что кеширования нет.
            * Исключение: если в ТЗ прописано "кешировать все запросы", тогда логика обратная - если не прописано "не
              кешировать" - то кешируем. Но такое описание редко встречается.
        * Даже если запрос при ошибке не отображает никаких ошибок и данные отображаются из кеша, проверяй это
          поведение в проверке с ошибкой, а не в проверке успеха.
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * В проверках без кеша в results добавляй логику сохранения кеша в явном виде если выполняются условия.
            * В проверках с кешем составляй сценарии, где кеш используется, а так же сценарии, где кеш обнуляется
              (например если параметры поменяются)
            * Кеш может быть локальным (фронтэнд решает когда кешировать) или же зависеть от бэкэнда. В таком случае
              может быть 30х ответ на запрос или же предварительный запрос OPTIONS с хешем в заголовках для определения
              когда нужно обновить запрос. Всегда внимательно определяй механизм кеширования и условия использования.
    2. Запрос с ошибкой
        * Формат названия: "F. S - T, кеш, ошибка" / "F - T, кеш, ошибка".
          Например "Каталог - запрос списка товаров, кеш, ошибка".
          Оригинальные тесты помечаются "без кеша", например "Каталог - запрос списка товаров, без кеша, ошибка".
        * Аналогично успешному кешированию, если в требованиях не указано кеширования - проверки на кеширование не
          нужны.
        * Если кеширование очень простое, например единственная логика это "в случае ПТР с ошибкой - отображается старый
          контент", то проверяй данную логику в тестах на запросы с ошибкой и не делай проверки на кеширование.
          Для проверок на кеширование обязательно наличие *позитивной* логики кеширования.
        * Логика совпадает с логикой запросов с ошибкой и логикой успешного кеширования со следующими уточнениями:
            * Проверяй как должен вести себя продукт в случае ошибок при наличии кеша. Например, без интернета может
              отображаться содержимое из кеша (если кеширование подразумевает отсутствие запроса) или же отображать
              ошибку (если логика зависит от запроса с 30х статусом или других механизмов)
7. Логика работы UI
    1. Логика работы
        * Формат названия: "F. S. E - логика работы" / "F. E - логика работы".
        * Проверка нужна только для элементов с логикой работы сложнее чем одно действие = 1 результат.
        * Элементы унифицированные. Даже если в Android и iOS они называются по-разному, описывай общие элементы.
        * Если логика отличается на платформах для одного элемента - в action или data указывай платформу и используй
          разные шаги
        * Если нужно проверить отображение и проверить что произойдет по тапу на элемент, то эти шаги стоит объединить,
          если это не нарушает логику тестирования. Например, два шага
          ```
          1. Найти карточку -> На карточке есть кнопка X.
          ---
          2. Тапнуть на кнопку X -> Отправляется запрос
          ```
          можно заменить одним
          ```
          1. Найти карточку\n2. Тапнуть на кнопку X -> Отправляется запрос
          ```
          Анти-пример которого нужно избегать:
          steps: `[ { action: '1.Нажать кнопку', result: '...' }, { action: '2.Дождаться ответа', result: '...' } ]`.
          Это должно быть объединено в один шаг.
        * Проверка интеграции переиспользуемых компонентов
            * Принцип: Если один и тот же компонент (например, карточка товара, баннер) используется в нескольких местах
              на одном экране или в рамках одной фичи, недостаточно протестировать его логику только один раз.
            * Реализация:
                * Для каждого места, где используется этот компонент, добавляется легкий "интеграционный" шаг.
                * Пример шага:
                    * Action: "В секции 'Секция A' тапнуть на элемент 'Элемент X'".
                    * Result: "Отправляется запрос {{HTTP_METHOD}} {{/api/path}}."
                    * Этот шаг не проверяет все исходы (например, успешный ответ или ошибку), а лишь подтверждает, что
                      компонент в данном конкретном месте "подключен" правильно и инициирует ожидаемое действие.
        * Проверка синхронизации состояния (State Synchronization)
            * Принцип: Если действие над одним элементом UI должно повлечь за собой изменение другого элемента (на том
              же или другом экране), это необходимо проверять явно.
            * Реализация:
                * В предусловии теста (data или отдельный шаг) необходимо создать ситуацию, когда синхронизация может
                  быть проверена.
                * В result нужно явно указать, что все зависимые элементы обновили свое состояние
                  одновременно.
                * Типовые сценарии для проверки:
                    * Избранное: Добавление товара в избранное в одном списке должно обновлять иконку у этого же товара
                      во всех других списках на экране.
                    * Корзина: Изменение количества товара на его детальной странице должно обновлять иконку/бейдж
                      корзины в таб-баре. Добавление товара в корзину из каталога должно менять состояние кнопки
                      'Добавить' на степпер '+/-' у всех карточек этого товара.
                    * Уведомления: Прочтение уведомления на экране уведомлений должно обнулять счетчик на иконке
                      профиля/колокольчика.
        * Разделение ответственности при навигации:
            * Принцип: При тестировании сценариев, включающих переход с Экрана А на Экран Б, необходимо четко разделять
              их зоны ответственности.
            * Реализация:
                * Тест для Экрана А должен проверять только сам факт навигации и корректность данных (параметров),
                  передаваемых на Экран Б. В этом тесте не должно быть проверок сетевых запросов, которые инициирует
                  Экран Б.
                * Тесты для Экрана Б должны описывать его поведение при инициализации с полученными параметрами. Именно
                  в этих тестах нужно проверять отправку запросов, обработку состояний загрузки, ошибок и отображение
                  данных.
        * Типовые проверки общие для разных элементов (чтобы не дублировать)
            * Логика отображения (в том числе в зависимости от параметров ответа на запрос)
            * disable состояние
        * Типовые проверки для разных элементов (не полный список)
            * Кнопки
                * изменение внешнего вида
                * появление алёртов и их логика (например предупреждение при закрытии экрана)
            * Обычные поля
                * валидация (триггер валидации (смена фокуса, кнопка, моментально), текстовки ошибок под полем)
                * тип клавиатуры (*обязательно* проверяй для полей e-mail, что клавиатура должна быть e-mail)
                * логика при тапе (например появление маски, позиция каретки)
                * возможность стирать текст и располагать каретку (например в ОТП полях может быть запрет на позицию)
                * возможность копировать и вставлять текст (только возможность, без проверки символов)
                * предзаполнение (если есть)
                * сложная вставка (по маске, например вставка телефона с кодом страны, без кода итд)
            * Поле пароля
                * аналогично обычному полю
                * Валидация (регулярное выражение, доступные символы, ошибка под полем)
                * Логика скрыть/показать пароль (в том числе виден индикатор всегда или нет)
            * Поле поиска
                * аналогично обычному полю
                * крестик стирания (логика появления, логика тапа (запрос))
                * закрытие поиска (стрелка назад, кнопка отмена)
                * отдельный экран для поиска или просто поле
                * локальный поиск или запрос
                * если локальный поиск - какие поля участвуют в поиске (если элементы списка состоят из нескольких)
                * задержка поиска (если запрос, чтобы не запрашивать сразу по мере ввода)
                * минимальное количество символов для запроса
                * история поиска (если есть отдельный запрос - покрыть обязательно запросными проверками)
            * Таймер ОТП кода
                * Ожидание таймера
                * Сворачивание приложения
                * Выйти с экрана и вернуться на экран еще раз (в идеале таймер останется)
                * Для запроса делай отдельные проверки даже если запрос такой же как при изначальном отправлении и
                  проверь что таймер успешно стартует, или не стартует если ошибка
            * Чекбоксы / радиобаттоны / Свитчи
                * взаимодействие с параметрами запроса (выбран = true, не выбран = false)
                * изначальное состояние
            * Карусель
                * Зацикленная или нет (возможность бесконечного скролла)
                * синхронизация с другими компонентами (например добавление в корзину)
            * Степпер
                * Логика удаления (минус до нуля)
                * Возможность вводить количество в поле
                * Задержка запроса (возможность несколько раз изменить слайдер и отправить запрос только после idle)
                * Обязательно проверяй все варианты использования степпера даже если они не описаны в требованиях
            * Сегмент контрол
                * Выбранный таб по умолчанию
                * логика формирования табов (если зависит от сервера)
                * возможность свайпать между табами (есть по умолчанию)
                * отправка запросов (не детали, а факт отправки) (часто отправляется только один раз)
                * логика ПТР (обновляются все табы или текущий выбранный)
            * Таббар
                * отдельно покрывается редко, но при переходах между экранами обязательно проверять
            * Слайдер
                * максимальные и минимальные значения (сами числа, сами границы тестируются отдельно)
                * синхронизация с полями ввода (если есть)
                * шаг слайдера
                * где используются значения слайдера
            * Дата пикер
                * Ограничения выбора
                * Стартовые значения (текущие если редактирование поля)
            * Календарь
            * Диалоги
            * Вебвью
                * Какой вид вебвью (customtabs / браузер / интеграция в приложение)
                * Открываемая ссылка
            * Изображения
                * Если локальное (без сервера) - покрывай в компоновке и не делай тест на логику
                * Заглушки если ошибка/нет ссылки
                * допускается покрытие запроса изображений в логике если нет никакой обработки ошибок, кеша итд)
    2. Позитивные проверки
        * Формат названия: "F. S. E - позитивные проверки" / "F. E - позитивные проверки".
        * Тест нужен только для тестирования элементов с явным разграничением допустимых и запрещенных значений
            * Ограничения длины ввода символов
            * Ограничения символов (например запрет ввода эмоджи)
            * Регулярные выражения
        * Почти все такие тесты - поля ввода и почти любое поле ввода должно иметь позитивные и негативные тесты
        * Если логика работы элемента затрагивает только работу с граничными значениями - допустимо описать логику
          работы внутри позитивной проверки для сокращения количества тестов.
        * Типовые проверки внутри
            * Успешные граничные значения (например корректная длина телефона). Классы не проверяем т.к. граничное
              значение состоит в том же классе.
            * Допустимые символы (в идеале одной проверкой)
            * Регулярное выражение (несколько вариантов, но не избыточно). Обязательно укажи в data само регулярное
              выражение
    3. Негативные проверки
        * Формат названия: "F. S. E - негативные проверки" / "F. E - негативные проверки".
        * Тест аналогичен позитивным проверкам по смыслу, но проверяет негативные кейсы требований
        * Типовые проверки внутри
            * Негативные граничные значения (граница +- 1)
            * Пустые поля
            * Недопустимые символы (в меру, но не избыточно)
            * Не попадание в регулярное выражение (обязательно указать регулярное выражение в data)
            * Запрет на эмодзи (если есть)
            * Запрет вставки (если есть)
            * Локальная блокировка на попытки с ошибкой (если блокировка приходит в запросе - обработай в запросной
              проверке)

##### Правила по содержанию проверок

* Используй русский язык кроме непереводимых слов. Далее устойчивые слова которые нужно предпочитать:
    * Снэкбар или снэк (вместо snackbar итд)
    * Таббар (вместо tab bar, TabBar итд)
* В result/data не должно быть "или/если" логики. Если есть условие и два варианта - пиши два шага в тесте и проверяй
  результат явно в каждом шаге. Тестовый шаг должен однозначно выступать проверкой, а не описанием логики.
  Допустимо описывать "и" условия т.к. они означают одновременность событий.
  Допустимо предоставлять несколько значений из одного класса эквивалентности в data т.к. условие все равно одно.
* Точки входа фич покрываются переходами в других фичах, не дублируй.
* При использовании предусловий, всегда указывай текстом, что это предусловие. Будь стабильным в формате предусловий и
  обязательно указывай ключевое слово "Предусловие", например
  ```
  **Предусловие**: нет кеша
  1. Проскроллить
  2. Тапнуть на кнопку
  ```
  Если предусловие простое - оставляй его на одной строке. Если длинное - расписывай в несколько строк.
* Как уже писал в структуре, если поле не сложное и покрыто позитивными проверками, объедини логику работы внутрь.
* При анализе ТЗ ты обязан уделять особое внимание любой условной логике, описывающей разные состояния одного и того же
  компонента или экрана.
  Ищи ключевые слова и конструкции: if/else, switch/case, "если... то...", "в зависимости от...",
  state=..., "Состояния:".
  В тестах и их содержимом ты должен покрыть *все* условные ветки.
  Недопустимо игнорировать состояния, даже если они кажутся минорными.
* Для каждого UI элемента, найденного на экране (кнопка, поле ввода, изображение, и т.д.), ты обязан применить все
  релевантные типовые проверки из раздела "Логика работы UI", даже если в ТЗ на конкретную фичу эти проверки не
  упоминаются.
  Правила из этого раздела имеют более высокий приоритет, чем неполнота ТЗ. Считай, что это базовые требования к
  качеству, которые должны быть проверены всегда.
  Пример: Если ты видишь на экране упоминание изображения и имеющийся параметр в swagger, ты должен автоматически,
  без явного указания в ТЗ фичи, создать проверки на случай пустой/невалидной ссылки и ошибки загрузки, как это описано
  в правилах для элемента "Изображения".
* Если в документации встречаются противоречия, неполные данные или явные TODO, сделай наиболее вероятное предположение,
  основанное на лучших практиках мобильной разработки. Опиши это предположение в шаге теста как требуемое поведение без
  слов-маркеров неуверенности (таких, как 'вероятно', 'возможно', 'например'). Вместо этого вырази свою неуверенность
  текстом-иконкой "(?)". Названия всех тестов с (?) должны начинаться с "TODO название" чтобы было видно сразу.
  После генерации тестов сделай сводку всех моментов в проверках которые вызвали у тебя неуверенность в виде
  пронумерованного списка.
  Частные (но не избыточные) случаи для такой обработки
    * Для каждого запроса в проверках явно проверяй лоадер. Если в ТЗ написано, что лоадера нет, тогда в проверке опиши
      явно, что лоадера нет. В случаях когда не описано какой лоадер нужен, обработай наиболее вероятный вариант лоадера
      (по умолчанию лоадеры нужны) и добавь "(?)".
    * Обработка двойных тапов:
        * Принцип: Критически важные сценарии (двойные нажатия, потеря сети в середине процесса) могут пропускаться в
          ТЗ.
        * Реализация: При тестировании любого действия, инициирующего запрос (нажатие кнопки, переключатель, поле,
          свитчер), необходимо проверять поведение при многократном быстром нажатии.
            * Ожидаемое поведение по умолчанию: Сразу после первого тапа интерактивный элемент должен
              блокироваться (переходить в состояние disabled + лоадер) до завершения запроса, предотвращая отправку
              повторных запросов.
            * Если в ТЗ поведение не описано: предполагай поведение по умолчанию, но в описании теста или шага
              добавь (?).
* Следуй следующим принципам:
    * Принцип полноты: Ты обязан проанализировать каждый предоставленный документ и каждую его часть — текстовые
      аннотации, списки, таблицы, ссылки на другие документы. Нельзя отдавать предпочтение структурированной
      информации (таблицам) перед описательной (текстом). Все требования равнозначны. Как обрабатывать
      конфликты/пропуски описано выше.
    * Принцип синтеза: Для каждой фичи или экрана ты должен синтезировать единую картину из всех источников.
      Если фича "X" описана в файле Y.md и ссылается на общий компонент A, ты должен объединить требования из обоих
      документов. Требования из "контекстного" документа (X) имеют приоритет и дополняют требования из "общего"
      документа (A).
    * Принцип интерактивности: Любой элемент, упомянутый в ТЗ как объект, с которым пользователь может
      взаимодействовать (тап, свайп, ввод текста), должен быть покрыт тестами. Это включает в себя кнопки (даже
      текстовые в заголовках разделов), карточки, баннеры, поля ввода и т.д., независимо от того, где они описаны — в
      тексте, таблице или на диаграмме. Если для интерактивного элемента не описан результат действия, отметь это как
      проблему в ТЗ (как описано выше, (?), TODO и список после генерации).
* Ограничение скоупа при взаимодействии между фичами:
    * Принцип: Если действие в рамках тестируемой фичи (Фича А) приводит к переходу в другую фичу (Фича Б), которая не
      входит в текущий скоуп (описанный в самом начале), тестирование должно останавливаться на границе фич.
    * Реализация:
        * В тесте для Фичи А нужно проверить только сам факт перехода и, если применимо, корректность передаваемых
          параметров.
        * Запрещено создавать тесты, описывающие логику работы Фичи Б (ее запросы, состояния, компоновку), так как
          предполагается, что они будут покрыты в рамках тестирования самой Фичи Б.
    * Пример:
        * Фича в скоупе: "Главная".
        * Действие: Тап на кнопку "Профиль".
        * Правильный тест для "Главной": Action: "Тапнуть на кнопку 'Профиль'". Result: "Происходит переход на экран
          'Профиль'".
        * Неправильно: Создавать для фичи "Главная" тесты "Профиль - компоновка", "Профиль - запрос данных" и т.д.

### Самопроверка

Финальная самопроверка перед генерацией ответа:

* Проверить, что каждый шаг, который инициирует API-вызов, содержит явное указание {{HTTP_METHOD /path}} в поле action
  или result.
* Проверить, что сценарии "действие пользователя -> ответ сервера" не разбиты на несколько шагов в массиве steps, а
  объединены в один шаг с использованием нумерованных списков внутри полей action и result.