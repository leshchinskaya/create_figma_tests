На основании артефактов и информации ниже, сгенерируй сценарные смоук-тесты на фичу "Главная" и подфичу "Витрина"
Перед этим детально и подробно проанализируй информацию и вводные данные и только потом генерируй ответ в соответствии с
правилами.
Кроме логики фичи обязательно обдумай содержание тестов прежде чем генерировать их.
За хорошие, детальные и продуманные тесты ты получишь награду $200.

### Бизнес-требования по фиче

Описание логики с точными названиями фич, секций и экранов из Figma.
Воспринимай логику из раздела "Общее" как то, что стоит учитывать при генерации (например общая обработка ошибок), но не
как фичу которую нужно покрыть тестами.

Содержимое файла `req.md`:

```markdown
{{REQ_CONTENT}}
```

### Swagger-спецификация

Описание API, моделей и параметров запросов.
Ссылка на Swagger: {{SWAGGER_URL}}
Содержимое файла `swagger.yaml`:

```yaml
{{SWAGGER_CONTENT}}
```

### Компонентные тесты

Подробные компонентные тесты. Используй их для лучшего понимания логики работы фичи.

```csv
{{COMPONENT_TESTS_CONTENT}}
```

### Правила генерации тестов

#### Спецификация формата тестов

Формат вывода - единый JSON-файл с массивом объектов.
Каждый объект обязан соответствовать схеме TestCase (см. ниже) и описывать одну Jira сущность Test.
Не оборачивай результат в Markdown, выводи чистый JSON.

```yaml
{{JSON_SCHEME_CONTENT}}
```

Правила:

* summary - ≤100 символов, декларативно. В конце не ставь точку. Формат наименования:
    * "Фича. Экран/шторка (итд) - сценарий, уточнение".
    * Далее для удобства F = фича, S = экран.
    * Если фича == экран, то "F - сценарий, уточнение".
    * Если экраны вложенные - указывай цепочку, например "F. S1. S2 - сценарий".
* description - должен содержать название файла ТЗ, ссылку на дизайн и ссылку на swagger. Каждый пункт на отдельной
  строке
* labels - Лейблы пишутся слитно без пробелов. Пока что передавай только "smoke".
* steps - action и result не могут быть пустой строкой, data может быть
* estimate - integer, минуты
* testCaseType - всегда scenario
* testRepositoryPath - обязательно в нижнем регистре. Корневая папка - название фичи из документации. Если фича состоит
  из нескольких подфич - делай для каждой экрана подпапку с названием этой подфичи.

Важные нюансы:

* Внимательно следи за синтаксисом, результатом должен быть валидный массив json объектов в соответствии со схемой.
* Если внутри json нужны кавычки (например название кнопки), используй одиночные кавычки (').
* *Никогда* не используй `` (backticks) для monospace форматирования. Вместо этого используй {{text}} конструкцию.
* Для блоков кода (если нужны) *всегда* используй "{code}text{code}" конструкцию, но будь внимателен с фигурными
  скобками.
* Для форматирования запросов приоритизируй {{text}} формат в виде списка вместо блока кода.
* В тз могут встречаться конструкции с {}, например описание запроса "GET /collection/{collectionId}".
  В этом случае используй <> для замены фигурных скобок чтобы правильно форматировалось в Jira.
  Например "{{GET /collection/<collectionId>}}"
* Запрет на использование ` (backticks) и обязательная самопроверка:
    * Правило: Использование символа обратной кавычки (backtick) `` для любого вида форматирования, включая выделение
      переменных, фрагментов кода или текста monospace шрифтом, строго запрещено. Вместо этого всегда используй
      конструкцию {{текст}}.
    * Пример:
        * Неправильно: Отображается текст на основе `expiring` и `expiresAt`.
        * Правильно: Отображается текст на основе {{expiring}} и {{expiresAt}}.
    * Процедура самопроверки: Перед тем как завершить генерацию ответа, ты обязан выполнить финальную проверку всего
      сгенерированного JSON на предмет наличия символа обратной кавычки (`). Если хотя бы один такой символ найден, ты
      должен немедленно исправить его на корректный формат {{}} перед выдачей финального ответа.
    * Исключение: единственным исключением может быть использование этого символа не для форматирования, а для
      содержания проверки, например в поле нельзя ввести этот символ и надо явно указать этот запрет.

#### Структура проверок и их содержимое

##### Структура проверок

Общие правила:

* В описании шагов тестов придерживайся императивной инфинитивной формы (сделать, тапнуть итд) для действий QA, и
  декларативной для среды (в прошедшем времени для action, в настоящем времени для result. что-то случилось -> что-то
  отображается).
  При этом не описывай *как* добиться этого эффекта (например, никогда не пиши "подменить ответ на запрос").
* Сценарии должны отражать более высокоуровневое поведение системы, чем компонентные проверки, фокусируясь на том что
  видит пользователь. Из логики нужно фокусироваться на самом главном поведении, а не на мелочах.
* Сценарии должны иметь конечную цель внутри этой фичи, которая продиктована тем как эту фичу будет использовать
  пользователь.
* Одна сущность тест - один основной проверяемый сценарий (например, успешный или неуспешный). Не смешивай проверку
  позитивного и негативного исхода в одном тест-кейсе, если это не является логичным продолжением одного сценария.
* Группируй действия сценария по ожидаемым результатам:
    * В result не должно быть нумерованных списков/маппинга с action действиями, только разовые одновременные результаты
      после действий.
    * В action допустимо использовать нумерованные списки, но действия не должны "забегать вперед результата" или
      дублировать прошлые шаги (если это не часть сценария).
* Объединяй логически последовательные шаги пользователя в один сценарий, особенно для "счастливого пути" (happy path).
  Например, успешная первоначальная загрузка экрана и его последующее повторное открытие с использованием кэша могут
  быть шагами одного теста, так как это отражает полный и частый цикл взаимодействия пользователя.
* Разделение логики теста по полям action/data/result:
    * action - содержит действие необходимое для достижения проверяемого результата.
    * data - входные данные и предусловия, в некоторых случаях данные для результата (например список параметров и их
      значений, которые ожидаются).
    * result - проверяемый результат после выполнения действий action с учетом данных data.
* Расположение предусловия:
    * По умолчанию предусловия располагаются в data.
    * Если же data нужно для данных result, то предусловие нужно располагать в action над шагами.
* Внутри *result* если нужны *одновременные* проверяемые результаты (логическое AND) - используй bullet-list для
  *каждого* результата. Например:
  ```
  - Отображается кнопка X.
  - Кнопка Y отсутствует.
  ```
* Внутри *action* если нужны *последовательные* действия - используй нумерованный список для *каждого* действия/условия.
  Например:
  ```
  1. Перейти на экран X.
  2. В ответе на запрос Y пришел параметр P.
  ```
* При использовании списков в полях action или result, следуй синтаксису Jira для вложенности:
    * Для маркированных списков используй - для первого уровня, -- для второго, --- для третьего и так далее.
    * Для нумерованных списков используй # для первого уровня, ## для второго, и так далее.

Пример сценария:
Название: Авторизация - успешная авторизация

| action                                                                                | data                                                                            | result                                                                                              |
|---------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| 1. Ввести верный логин<br/> 2. Ввести верный пароль<br/> 3. Тапнуть на кнопку "Войти" | Предусловие: <br/>* Пользователь не авторизован <br/>* открыт экран авторизации | * Во время загрузки показывается лоадер<br/> * После загрузки открывается экран ввода ОТП кода      |
| Ввести корректный ОТП код                                                             | 338610 всегда на тестовом сервере                                               | * После ввода последней цифры происходит загрузка<br/> * После загрузки открывается экран "Профиль" |

##### Правила по содержанию проверок

* Используй русский язык кроме непереводимых слов. Далее устойчивые слова которые нужно предпочитать:
    * Снэкбар или снэк (вместо snackbar итд)
    * Таббар (вместо tab bar, TabBar итд)
* Называй (Error/Empty/No Connection) State на английском несмотря на правило использовать русский язык.
* В сценарии не должно быть "или/если" логики. Если есть важное условие и два варианта сценария - пиши два раздельных
  теста и проверяй их явно (через действия или предусловия).
* Начальная точка сценария не обязательно должна начинаться с начала фичи. Если сценарии расходятся на каком-то экране,
  более чем допустимо начать второй сценарий с этого экрана указав в предусловии на каком экране находится пользователь
  и другие условия необходимые для сценария.
* При использовании предусловий, всегда указывай текстом, что это предусловие. Будь стабильным в формате предусловий и
  обязательно указывай ключевое слово, например "Предусловие"
  ```
  **Предусловие**: нет кеша
  1. Проскроллить
  2. Тапнуть на кнопку
  ```
  Если предусловие простое - оставляй его на одной строке. Если длинное - расписывай в несколько строк.
* Классификация тестов (smoke vs sanity)
  Ты должен классифицировать тесты на два типа и добавлять соответствующий лейбл в поле labels.
  * smoke: Критически важные тесты. Включай сюда только основные позитивные сценарии (happy path). Это проверка того, что
    главная функция фичи работает при идеальных условиях. Если этот тест падает, фича считается полностью
    неработоспособной. В этих сценариях не должно быть обработки ошибок и других негативных сценариев.
  * sanity: Все остальные проверки. Включай сюда:
  * Негативные сценарии (обработка ошибок сервера 5xx, клиентских ошибок 4xx, отсутствие сети).
  * Проверки граничных случаев (пустые списки, нулевые значения, некорректные данные).
  * Проверки второстепенных функций, которые не блокируют основную ценность фичи (например, Pull-to-Refresh).
* Для smoke тестов ставь приоритет Blocker или Critical, для sanity — Normal или Minor.
* Следуй следующим принципам:
    * Принцип полноты: Ты обязан проанализировать каждый предоставленный документ и каждую его часть — текстовые
      аннотации, списки, таблицы, ссылки на другие документы. Нельзя отдавать предпочтение структурированной
      информации (таблицам) перед описательной (текстом). Все требования равнозначны. Как обрабатывать
      конфликты/пропуски описано выше.
    * Принцип синтеза: Для каждой фичи или экрана ты должен синтезировать единую картину из всех источников.
      Если фича "X" описана в файле Y.md и ссылается на общий компонент A, ты должен объединить требования из обоих
      документов. Требования из "контекстного" документа (X) имеют приоритет и дополняют требования из "общего"
      документа (A).
* Ограничение скоупа при взаимодействии между фичами:
    * Принцип: Если действие в рамках тестируемой фичи (Фича А) приводит к переходу в другую фичу (Фича Б), которая не
      входит в текущий скоуп (описанный в самом начале), но результат сценария требует выполнения действий в фиче Б, то
      тестирование должно описывать наиболее типичный сценарий для завершения сценария, без явной проверки результата.
    * Реализация: Фича А описывает наиболее общий или простой путь завершения сценария. Фича Б в предусловиях описывает
      наиболее общий ли релевантный набор условий для начала проверки.
    * Например:
      Фича А - корзина, Фича Б - оплата. В корзине есть 5 явно уникальных видов блюд, в оплатах есть 3 способа оплаты и
      2 способа доставки. В сценариях по фиче А нам важно проверить что каждый из видов блюд успешно оформляется,
      поэтому в завершении сценария мы пишем шаг "успешно оплатить заказ способом 1" -> "оформляется заказ с нужными
      блюдами". В фиче Б же нам нужно проверить каждый способ оплаты. Для этого мы пишем предусловие с адекватной
      корзиной и расписываем сценарии оплаты.
