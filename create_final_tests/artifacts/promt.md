На основании артефактов и информации ниже, сгенерируй тесты на фичу "Главная" и подфичу "Витрина"
Перед этим детально и подробно проанализируй информацию и вводные данные и только потом генерируй ответ в соответствии с
правилами.
Кроме логики фичи обязательно обдумай содержание тестов прежде чем генерировать их.
Производи анализ на английском языке, но весь вывод делай **строго** на русском языке.

### Бизнес-требования по фиче

Описание логики с точными названиями фич, секций и экранов из Figma.
Воспринимай логику из раздела "Общее" как то, что стоит учитывать при генерации (например общая обработка ошибок), но не
как фичу которую нужно покрыть тестами.

Содержимое файла `req_showcase.md`:
todo req -> общее

```markdown
{{REQ_SHOWCASE_CONTENT}}
```

### Swagger-спецификация

Описание API, моделей и параметров запросов.
Содержимое файла `swagger.yaml`:

```yaml
{{SWAGGER_CONTENT}}
```

### Тесты на дизайн

Краткие сценарии с Summary, содержащие названия секций/экранов из Figma.
Используй их содержимое для тестов компоновки экранов.
Содержимое файла `tests_from_figma.csv`:

```csv
{{TESTS_FROM_FIGMA_CONTENT}}
```

### Правила генерации тестов

#### Спецификация формата тестов

Формат вывода - единый JSON-файл с массивом объектов.
Каждый объект обязан соответствовать схеме TestCase (см. ниже) и описывать одну Jira сущность Test.
Не оборачивай результат в Markdown, выводи чистый JSON.

```yaml
{{JSON_SCHEME_CONTENT}}
```

Правила:

* summary - ≤100 символов, декларативно. В конце не ставь точку. Строго соблюдай формат названия из структуры проверок.
* description - должен содержать название файла ТЗ и ссылку на дизайн (из тестов figma). Каждый пункт на отдельной
  строке
* labels - Лейблы пишутся слитно без пробелов. Пока что передавай пустой список.
* steps - action не может быть пустой строкой, data и result могут быть (result может быть пустым только для глобальных
  предусловий или тестов на компоновку)
* estimate - integer, минуты
* testCaseType - всегда component
* testRepositoryPath - обязательно в нижнем регистре. Корневая папка - название фичи из документации. Если фича состоит
  из нескольких экранов - делай для каждого экрана подпапку с названием экрана, но не делай вложенные экраны, только 1
  уровень глубины.

Важные нюансы:

* Внимательно следи за синтаксисом, результатом должен быть валидный массив json объектов в соответствии со схемой
* Если внутри json нужны кавычки (например название кнопки), используй одиночные кавычки (')
* Вместо `` (backticks) *всегда* используй "{{<text>}}", но будь внимателен с фигурными скобками
* Для блоков кода (если нужны) *всегда* используй "{code}<code>{code}" конструкцию, но будь внимателен с фигурными
  скобками

#### Структура проверок и их содержимое

##### Структура проверок

У нас есть четкая структура проверок от которой нельзя отклоняться за *редкими* исключениями. Ниже предоставлено
описание проверок и подробности их написания. В случае отклонения обязательно укажи это в ответе после генерации тестов.

Общие правила:

* Все проверки имеют следующий формат наименования: "Фича. Экран/шторка (итд). Элемент - тест, уточнение".
  Далее для удобства F = фича, S = экран, E = элемент.
  Если нет элемента, то наименование упрощается до "F. S - тест, уточнение".
  Если фича == экран, то "F - тест, уточнение".
  Если экраны вложенные - указывай цепочку, например "F. S1. S2 - тест".
  Уточнение не обязательное, но если оно есть - после запятой после теста.
  Более подробно примеры будут разобраны в каждом конкретном виде теста.
  Никогда не ставь точку в конце названия или перед дефисом.
  Строго следуй формату наименования за исключением тестов которые явно не попадают под классификацию. В таком случае
  *обязательно* укажи это в ответе после генерации тестов.
* Все проверки обязательно содержат ссылку на ТЗ и дизайн
* Все описанные ниже тесты следуют принципу best effort - они одновременно обязательные, но только при условии, что
  логика которую они покрывают - содержится и в проверке есть смысл и она не избыточная.
* В описании шагов тестов придерживайся императивной инфинитивной формы (сделать, тапнуть итд) для действий QA, и
  декларативной для среды (в прошедшем времени для action, в настоящем времени для result, что-то случилось -> что-то
  отображается).
  При этом не описывай *как* добиться этого эффекта (например, никогда не пиши "подменить ответ на запрос")

1. Компоновки
    1. Компоновка экрана
        * Формат названия: "F. S - компоновка" / "F - компоновка"
        * Шаги - каждый шаг проверяет один элемент, где action = элемент. Порядок сверху вниз по экрану.
            * Статусбар - упомянуть, на iOS по тапу скроллит в начало экрана списки
            * AppBar / NavBar - проверить заголовок и описать какие содержатся элементы. Если с элементами можно
              взаимодействовать - описать их в следующих шагах
            * Возврат назад - после описания кнопки назад или крестика нужно добавить как обрабатывается:
                * backswipe на iOS - возврат на прошлый экран
                * системная кнопка назад на Android - возврат на прошлый экран
            * Картинки - просто упомянуть
            * Текст - корректный текст указать в result, в action указать краткое название текста. Если текст имеет
              ограничение по строкам - указать в result.
            * Кнопки - в action указать текст кнопки если есть, иначе описать. В result нужно проверить pressed state
              (достаточно упомянуть) и кратко описывает результат при тапе
            * Обычные поля - в result нужно указать placeholder
            * Поля поиска - аналогично, нужно указать hint
            * Остальные элементы делаются по аналогии
            * Если значения приходят в ответе на запрос - укажи в Data параметр ответа который влияет на значение
    2. Компоновка шторки
        * Все аналогично компоновке экрана, но в возврате назад проверяй:
            * Смахивание и тап на пустую область - зависит от требований
            * Backswipe iOS не работает
            * Тап на системную кнопку Android - работает
    3. Компоновка TUP (Thank You Page)
        * Все аналогично компоновке экрана со следующими уточнениями:
            * При возврате назад явно проверяй какой экран открывается, обычно это точка входа флоу, а не прошлый
              экран.
            * Бывают TUP с ошибкой, в таком случае создай еще один отдельный тест для проверки этого состояния.
    4. Компоновка Empty State/Error State/No Connection State
        * Все аналогично компоновке экрана, но создаем обязательно отдельные проверки под *каждый* state если они есть
        * Обязательно проверяем кнопку повтора действий если она есть
2. Логика работы в стеке экранов
    * Формат названия: "F. S - логика работы в стеке экранов" / "F - логика работы в стеке экранов"
    * Проверка нужна когда при закрытии экрана происходит не обычный возврат на прошлый экран, например есть обработка
      алёртом "вы точно хотите закрыть?", переход на какой-то экран и другие необычные события, например сохранение
      данных итд.
    * Шаги - каждый шаг описывает действие юзера и ожидаемое поведение. Возможные проверки:
        * Тап на кнопку - в result пишем ожидаемое поведение, например появление алёрта. Так же кратко описываем
          компоновку в этом шаге, включая текстовки алёрта
        * Отказ от алёрта (тап на кнопку нет)
        * Согласие с алёртом (тап на кнопку выйти)
        * Сохранение данных формы
        * Особая логика при сворачивании/разворачивании приложения
        * Очистка кеша/авторизации
3. Отправка запроса
    1. Отправка запроса
        * Формат названия: "F. S - запрос x" / "F - запрос x"
        * Запрос в названии должен отражать цель запроса, а не конкретный метод (например запрос авторизации, запрос смс
          кода)
        * Проверка нужна всегда при отправке запроса. Это можно происходить при открытии экрана, при нажатии на
          кнопку или по любой другой причине.
        * Если по триггеру отправляются несколько запросов (параллельно или последовательно) - это нужно обработать
          в одной проверке.
        * Важно глобально различать разницу между "кнопка открывает экран, а экран отправляет запрос" и "кнопка
          вызывает запрос". В первом случае в кнопке мы проверяем открытие экрана и не более, а запрос проверяем в
          тестах экрана.
        * Все успешные кейсы обрабатываются в одной сущности теста и разделяются шагами, недопустимо создавать
          несколько сущностей для одного запроса.
        * Шаги:
            * Каждый шаг это мини-сценарий который идет от триггера до конца запросов
            * Между action и result возникает маппинг - если есть список 1-2-3 в action, то result 1-2-3
              соответствуют результату *после* этого шага. Т.е. action 1 - result 1 - action 2 - result 2
            * Внутри шага если для номера выполняются одновременные действия или результаты - используй bullet-list
            * При указании запроса обязательно указывай метод и path. Используй bold или monospace форматирование.
            * Прикрепляй и описывай логику с параметрами если она важна для логики проверки, ссылайся на swagger.
            * Empty state считается позитивной проверкой, поэтому должен покрываться в этом тесте (при условии, что он
              есть)
            * При проверке лоадера упоминай что он должен длиться всю длительность запроса
            * Каждый шаг состоит из
                * Предусловие (только если нужно)
                * Триггер запроса (например тап на кнопку) - результат (какой запрос отправился, какой лоадер
                  отображается)
                * Успех запроса (как выглядит, например 200 и модель swagger) - результат (UI отображает X, Y, Z,
                  возможно отправляется следующий запрос)
                * 2 и 3 для каждого последовательного запроса. Параллельные запросы объединяются в один мини-шаг
    2. Отправка запроса с ошибкой
        * Формат названия: "F. S - запрос x, ошибка" / "F - запрос x, ошибка"
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * Вместо успеха мы проверяем обработку ошибок
            * Без интернета и таймаут проверяется в этом тесте вместе с HTTP ошибками.
            * Длительность таймаута должна быть явно прописана.
            * Для параллельных запросов важно проверить оба варианта (ошибка только 1 и только 2 запроса)
            * Группируй проверки по *обработке*. Например, если 400-500-таймаут обрабатываются одинаково, укажи их в
              Data списком, а без интернета отдельно.
            * В каждой такой проверке должны проверяться все общие ошибки (400-500-таймаут-без интернета и что еще есть
              в общем ТЗ) и специфичные указанные для конкретного запроса.
            * Большое внимание уделяй наличию и обработке 401/403 ошибок. Часто 401 вызывает refresh-token логику, а 403
              сигнализирует что токен протух, однако это должно быть явно описано в ТЗ.
            * В отличие от HTTP ошибок, без интернета не может случиться между запросами или для одного запроса из
              двух - по крайней мере это нереально проверить - поэтому используй логику "выключить интернет - триггер -
              результат"
4. Пагинация
    1. Пагинация
        * Формат названия: "F. S - пагинация" / "F - пагинация"
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * В ожидаемых результатах нужно проверить что содержимое не двоится и отображается в правильном порядке
    2. Пагинация с ошибкой
        * Формат названия: "F. S - пагинация, ошибка" / "F - пагинация, ошибка"
        * Логика совпадает с отправкой запроса с ошибкой со следующими уточнениями:
            * При ошибке может быть снек или небольшая заглушка. При снеке сразу проверяем что можно повторить
              пагинацию, заглушку проверяем далее отдельными тестами.
    3. Повтор пагинации
        * Формат названия: "F. S - повтор пагинации" / "F - повтор пагинации"
        * Проверка нужна только если после ошибки пагинации остается заглушка
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * Первым шагом проверяем компоновку заглушки
            * Далее - как обычно, для запросов
    4. Повтор пагинации с ошибкой
        * Формат названия: "F. S - повтор пагинации, ошибка" / "F - повтор пагинации, ошибка"
        * Проверка нужна только если после ошибки пагинации остается заглушка
        * Логика совпадает с отправкой запроса с ошибкой
5. Pull to refresh
    1. PTR
        * Формат названия: "F. S - PTR" / "F - PTR"
        * Проверка нужна только если на экране есть PTR
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * Важно вместо лоадера проверить индикатор загрузки - он должен длиться столько сколько длятся запросы
            * Нужно внимательно проверить какие запросы должны повторяться при PTR
    2. PTR с ошибкой
        * Формат названия: "F. S - PTR, ошибка" / "F - PTR, ошибка"
        * Проверка нужна только если на экране есть PTR
        * Логика совпадает с отправкой запроса с ошибкой со следующими уточнениями:
            * Внимательно учитывай обработку ошибки. В основном это снек, но может быть и Error State, тогда нужно
              указать правильные стейты (empty/error/no connection)
            * Там где поддерживается - не забывай empty ответ
6. Кеширование запросов
    1. Успешный запрос
        * Проверки на кеш дублируют проверки запросов. Дублируются все типы тестов - запрос, PTR, пагинация, повторы.
          При наличии логики с кешем, основной тест помечается уточнением "без кеша", и дополнительно пишется
          тест на проверку кеша.
        * Формат названия: "F. S - T, кеш" / "F - T, кеш". Например "Каталог - запрос списка товаров, кеш".
          Оригинальные тесты помечаются "без кеша", например "Каталог - запрос списка товаров, без кеша".
        * Кеширование запросов должно быть *явно* прописано в техническом задании для конкретного запроса, в противном
          случае считай что кеширования нет.
        * Логика совпадает с успешной отправкой запроса со следующими уточнениями:
            * В проверках без кеша в results добавляй логику сохранения кеша в явном виде если выполняются условия.
            * В проверках с кешем составляй сценарии, где кеш используется, а так же сценарии, где кеш обнуляется
              (например если параметры поменяются)
            * Кеш может быть локальным (фронтэнд решает когда кешировать) или же зависеть от бэкэнда. В таком случае
              может быть 30х ответ на запрос или же предварительный запрос OPTIONS с хешем в заголовках для определения
              когда нужно обновить запрос. Всегда внимательно определяй механизм кеширования и условия использования.
    2. Запрос с ошибкой
        * Формат названия: "F. S - T, кеш, ошибка" / "F - T, кеш, ошибка".
          Например "Каталог - запрос списка товаров, кеш, ошибка".
          Оригинальные тесты помечаются "без кеша", например "Каталог - запрос списка товаров, без кеша, ошибка".
        * Аналогично успешному кешированию, если в требованиях не указано кеширования - проверки на кеширование не
          нужны.
        * Если кеширование очень простое, например единственная логика это "в случае ПТР с ошибкой - отображается старый
          контент", то проверяй данную логику в тестах на запросы с ошибкой и не делай проверки на кеширование.
          Для проверок на кеширование обязательно наличие *позитивной* логики кеширования.
        * Логика совпадает с логикой запросов с ошибкой и логикой успешного кеширования со следующими уточнениями:
            * Проверяй как должен вести себя продукт в случае ошибок при наличии кеша. Например, без интернета может
              отображаться содержимое из кеша (если кеширование подразумевает отсутствие запроса) или же отображать
              ошибку (если логика зависит от запроса с 30х статусом или других механизмов)
7. Логика работы UI
    1. Логика работы
        * Формат названия: "F. S. E - логика работы" / "F. E - логика работы".
        * Проверка нужна только для элементов с логикой работы сложнее чем одно действие = 1 результат.
        * Элементы унифицированные. Даже если в Android и iOS они называются по-разному, описывай общие элементы.
        * Если логика отличается на платформах для одного элемента - в action или data указывай платформу и используй
          разные шаги
        * Типовые проверки общие для разных элементов (чтобы не дублировать)
            * Логика отображения (в том числе в зависимости от параметров ответа на запрос)
            * disable состояние
        * Типовые проверки для разных элементов (не полный список)
            * Кнопки
                * изменение внешнего вида
                * появление алёртов и их логика (например предупреждение при закрытии экрана)
            * Обычные поля
                * валидация (триггер валидации (смена фокуса, кнопка, моментально), текстовки ошибок под полем)
                * тип клавиатуры (*обязательно* проверяй для полей e-mail, что клавиатура должна быть e-mail)
                * логика при тапе (например появление маски, позиция каретки)
                * возможность стирать текст и располагать каретку (например в ОТП полях может быть запрет на позицию)
                * возможность копировать и вставлять текст (только возможность, без проверки символов)
                * предзаполнение (если есть)
                * сложная вставка (по маске, например вставка телефона с кодом страны, без кода итд)
            * Поле пароля
                * аналогично обычному полю
                * Валидация (регулярное выражение, доступные символы, ошибка под полем)
                * Логика скрыть/показать пароль (в том числе виден индикатор всегда или нет)
            * Поле поиска
                * аналогично обычному полю
                * крестик стирания (логика появления, логика тапа (запрос))
                * закрытие поиска (стрелка назад, кнопка отмена)
                * отдельный экран для поиска или просто поле
                * локальный поиск или запрос
                * если локальный поиск - какие поля участвуют в поиске (если элементы списка состоят из нескольких)
                * задержка поиска (если запрос, чтобы не запрашивать сразу по мере ввода)
                * минимальное количество символов для запроса
                * история поиска (если есть отдельный запрос - покрыть обязательно запросными проверками)
            * Таймер ОТП кода
                * Ожидание таймера
                * Сворачивание приложения
                * Выйти с экрана и вернуться на экран еще раз (в идеале таймер останется)
                * Для запроса делай отдельные проверки даже если запрос такой же как при изначальном отправлении и
                  проверь что таймер успешно стартует, или не стартует если ошибка
            * Чекбоксы / радиобаттоны / Свитчи
                * взаимодействие с параметрами запроса (выбран = true, не выбран = false)
                * изначальное состояние
            * Карусель
                * Зацикленная или нет (возможность бесконечного скролла)
                * синхронизация с другими компонентами (например добавление в корзину)
            * Степпер
                * Логика удаления (минус до нуля)
                * Возможность вводить количество в поле
                * Задержка запроса (возможность несколько раз изменить слайдер и отправить запрос только после idle)
            * Сегмент контрол
                * Выбранный таб по умолчанию
                * логика формирования табов (если зависит от сервера)
                * возможность свайпать между табами (есть по умолчанию)
                * отправка запросов (не детали, а факт отправки) (часто отправляется только один раз)
                * логика ПТР (обновляются все табы или текущий выбранный)
            * Таббар
                * отдельно покрывается редко, но при переходах между экранами обязательно проверять
            * Слайдер
                * максимальные и минимальные значения (сами числа, сами границы тестируются отдельно)
                * синхронизация с полями ввода (если есть)
                * шаг слайдера
                * где используются значения слайдера
            * Дата пикер
                * Ограничения выбора
                * Стартовые значения (текущие если редактирование поля)
            * Календарь
            * Диалоги
            * Вебвью
                * Какой вид вебвью (customtabs / браузер / интеграция в приложение)
                * Открываемая ссылка
            * Изображения
                * Если локальное (без сервера) - покрывай в компоновке и не делай тест на логику
                * Заглушки если ошибка/нет ссылки
                * допускается покрытие запроса изображений в логике если нет никакой обработки ошибок, кеша итд)
    2. Позитивные проверки
        * Формат названия: "F. S. E - позитивные проверки" / "F. E - позитивные проверки".
        * Тест нужен только для тестирования элементов с явным разграничением допустимых и запрещенных значений
            * Ограничения длины ввода символов
            * Ограничения символов (например запрет ввода эмоджи)
            * Регулярные выражения
        * Почти все такие тесты - поля ввода и почти любое поле ввода должно иметь позитивные и негативные тесты
        * Если логика работы элемента затрагивает только работу с граничными значениями - допустимо описать логику
          работы внутри позитивной проверки для сокращения количества тестов.
        * Типовые проверки внутри
            * Успешные граничные значения (например корректная длина телефона). Классы не проверяем т.к. граничное
              значение состоит в том же классе.
            * Допустимые символы (в идеале одной проверкой)
            * Регулярное выражение (несколько вариантов, но не избыточно). Обязательно укажи в data само регулярное
              выражение
    3. Негативные проверки
        * Формат названия: "F. S. E - негативные проверки" / "F. E - негативные проверки".
        * Тест аналогичен позитивным проверкам по смыслу, но проверяет негативные кейсы требований
        * Типовые проверки внутри
            * Негативные граничные значения (граница +- 1)
            * Пустые поля
            * Недопустимые символы (в меру, но не избыточно)
            * Не попадание в регулярное выражение (обязательно указать регулярное выражение в data)
            * Запрет на эмодзи (если есть)
            * Запрет вставки (если есть)
            * Локальная блокировка на попытки с ошибкой (если блокировка приходит в запросе - обработай в запросной
              проверке)

##### Правила по содержанию проверок

* Используй русский язык кроме непереводимых слов
* В result/data не должно быть "если" логики. Если есть условие и два варианта - пиши два шага в тесте и проверяй
  результат явно в каждом шаге. Тестовый шаг должен однозначно выступать проверкой, а не описанием логики.
* Точки входа фич покрываются переходами в других фичах, не дублируй.
* Как уже писал в структуре, если поле не сложное и покрыто позитивными проверками, объедини логику работы внутрь.
